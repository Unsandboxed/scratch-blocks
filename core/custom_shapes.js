/**
 * @fileoverview Custom block shape API
 * These methods are specific to the custom block shape api
 * this lets you add custom shapes
 */

/**
 * @name Blockly.CustomShapes
 * @namespace
 **/
goog.provide('Blockly.CustomShapes');

/**
 * A object with all the shapes in it
 * @private
 */
Blockly.CustomShapes.ALL_ = Object.create(null);

/**
 * Check if a shape exists
 * @param {string} shapeName The shape to look for
 * @returns {boolean} Whether or not the shape exists
 */
Blockly.CustomShapes.has = function(shapeName) {
  return Object.prototype.hasOwnProperty.call(this.ALL_, shapeName);
};

/**
 * Delete a shape
 * @param {string} shapeName The shape to delete
 * @returns {boolean} Whether or not it was deleted
 * @private
 */
Blockly.CustomShapes.remove = function(shapeName) {
  return this.has(shapeName) && (delete this.ALL_[shapeName]);
};

/**
 * Gets the shape
 * @param {string} The shape to get
 * @returns {object|undefined} The shape
 */
Blockly.CustomShapes.get = function(shapeName) {
  return this.ALL_[shapeName];
};

/**
 * Update the padding values in blockly from the shape info
 * @param {object} shapeInfo The info of the shape (should contain name and paddings!!)
 * @private
 */
Blockly.CustomShapes.updatePaddings = function(shapeInfo) {
  const SISP = Blockly.BlockSvg.SHAPE_IN_SHAPE_PADDING;
  for (const shapeName in SISP) {
    if (Object.prototype.hasOwnProperty.call(SISP, shapeName)) {
      if (shapeName === shapeInfo.name) continue;
      SISP[shapeName][shapeInfo.name] = shapeInfo.paddings.outer[shapeName] || shapeInfo.paddings.outer[Blockly.OUTPUT_SHAPE_ROUND];
    }
  }
  SISP[shapeInfo.name] = shapeInfo.paddings.inner;
};

/**
 * "Event" for when a new shape is registered
 * @param {object} shapeInfo The info of the shape generated by CustomShape.register
 * @private
 */
Blockly.CustomShapes.onShapeRegistered = function(shapeInfo) {
  Blockly.Extensions.register(`output_${shapeInfo.name}`, function(...args) {
    return shapeInfo.shape.outputExtension(Blockly, this);
  });
  const getInnerPad = shapeInfo.shape.getInnerPaddingFor.bind(shapeInfo.shape, Blockly);
  const getOuterPad = shapeInfo.shape.getOuterPaddingFor.bind(shapeInfo.shape, Blockly);
  shapeInfo.paddings = {
    inner: {
      [shapeInfo.name]: getInnerPad(shapeInfo.name),
      [0]: getInnerPad(0),
      [Blockly.OUTPUT_SHAPE_HEXAGONAL]: getInnerPad(Blockly.OUTPUT_SHAPE_HEXAGONAL),
      [Blockly.OUTPUT_SHAPE_ROUND]: getInnerPad(Blockly.OUTPUT_SHAPE_ROUND),
      [Blockly.OUTPUT_SHAPE_SQUARE]: getInnerPad(Blockly.OUTPUT_SHAPE_SQUARE),
      [Blockly.OUTPUT_SHAPE_OBJECT]: getInnerPad(Blockly.OUTPUT_SHAPE_OBJECT)
    },
    outer: {
      [shapeInfo.name]: getOuterPad(shapeInfo.name),
      // [0]: getOuterPad(0),
      [Blockly.OUTPUT_SHAPE_HEXAGONAL]: getOuterPad(Blockly.OUTPUT_SHAPE_HEXAGONAL),
      [Blockly.OUTPUT_SHAPE_ROUND]: getOuterPad(Blockly.OUTPUT_SHAPE_ROUND),
      [Blockly.OUTPUT_SHAPE_SQUARE]: getOuterPad(Blockly.OUTPUT_SHAPE_SQUARE),
      [Blockly.OUTPUT_SHAPE_OBJECT]: getOuterPad(Blockly.OUTPUT_SHAPE_OBJECT)
    }
  };
  for (const otherShapeName in this.ALL_) {
    if (this.has(otherShapeName)) {
      const otherShapeInfo = this.get(otherShapeName);
      shapeInfo.paddings.inner[otherShapeInfo.name] = getInnerPad(otherShapeInfo.name) || shapeInfo.paddings.inner[Blockly.OUTPUT_SHAPE_ROUND];
      shapeInfo.paddings.outer[otherShapeInfo.name] = getOuterPad(otherShapeInfo.name) || shapeInfo.paddings.outer[Blockly.OUTPUT_SHAPE_ROUND];
      otherShapeInfo.paddings.inner[shapeInfo.name] = otherShapeInfo.shape.getInnerPaddingFor(Blockly, shapeInfo.name);
      otherShapeInfo.paddings.outer[shapeInfo.name] = otherShapeInfo.shape.getOuterPaddingFor(Blockly, shapeInfo.name);
      this.updatePaddings(otherShapeInfo);
    }
  }
  this.updatePaddings(shapeInfo);
  shapeInfo.paths = {
    left: shapeInfo.shape.getLeftPath.bind(shapeInfo.shape),
    right: shapeInfo.shape.getRightPath.bind(shapeInfo.shape),
    argument: shapeInfo.shape.getArgumentPath(Blockly)
  };
};

/**
 * Registers a new custom shape
 * @param {string} shapeName The name of the custom shape (2 of the same are not allowed)
 * @param {object} shapeInfo The info about the shape
 */
Blockly.CustomShapes.register = function(shapeName, shapeInfo, categoryInfo) {
  if (this.has(shapeName)) {
    throw 'Cannot register 2 shapes under the same name';
  }
  const newShapeInfo = {
    name: shapeName,
    paddings: null,
    paths: null,
    width: shapeInfo.getWidth(Blockly),
    shape: shapeInfo,
    category: categoryInfo,
  };
  this.ALL_[shapeName] = newShapeInfo;
  this.onShapeRegistered(newShapeInfo);
};
